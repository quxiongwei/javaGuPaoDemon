单一职责原则
单一职责（Simple Responsibility Pinciple，SRP）是指不要存在多于一个导致类变更的原因。
假设我们有一个 Class 负责两个职责，一旦发生需求变更，修改其中一个职责的逻辑代码，
有可能会导致另一个职责的功能发生故障。这样一来，这个 Class 存在两个导致类变更的原因。
如何解决这个问题呢？我们就要给两个职责分别用两个 Class 来实现，进行解耦。后期需求变更维护互不影响。
这样的设计，可以降低类的复杂度，提高类的可 读 性 ， 提 高 系 统 的 可 维 护 性 ， 降 低 变 更 引 起 的 风 险 。
 总 体 来 说 就 是 一 个
Class/Interface/Method 只负责一项职责。
接下来，我们来看代码实例，还是用课程举例，我们的课程有直播课和录播课。
直播课不能快进和快退，录播可以可以任意的反复观看，功能职责不一样。还是先创建一个
Course 类：
public class Course {
public void study(String courseName){
if("直播课".equals(courseName)){
System.out.println(courseName + "不能快进");
}else{
System.out.println(courseName + "可以反复回看");
}
}
}
看代码调用：
public static void main(String[] args) { Course course = new Course(); course.study("直播课"); course.study("录播课");
}
从上面代码来看，Course 类承担了两种处理逻辑。假如，现在要对课程进行加密，
那么直播课和录播课的加密逻辑都不一样，必须要修改代码。而修改代码逻辑势必会相互影响容易造成不可控的风险。
我们对职责进行分离解耦，来看代码，分别创建两个类
ReplayCourse 和 LiveCourse： LiveCourse 类：
public class LiveCourse {
public void study(String courseName){
System.out.println(courseName + "可以反复回看");
}
}
ReplayCourse 类：
public class ReplayCourse {
public void study(String courseName){
System.out.println(courseName + "不能快进"); }
}
调用代码：
public static void main(String[] args) {
LiveCourse liveCourse = new LiveCourse(); liveCourse.study("直播课");
ReplayCourse replayCourse = new ReplayCourse();
replayCourse.study("录播课");
}
业务继续发展，课程要做权限。没有付费的学员可以获取课程基本信息，已经付费的学员可以获得视频流，
即学习权限。那么对于控制课程层面上至少有两个职责。我们可以把展示职责和管理职责分离开来，都实现同一个抽象依赖。
设计一个顶层接口,创建
ICourse 接口：
public interface ICourse {
//获得基本信息
String getCourseName();
//获得视频流
byte[] getCourseVideo();
//学习课程
void studyCourse();
//退款
void refundCourse();
}
我们可以把这个接口拆成两个接口，创建一个接口 ICourseInfo 和 ICourseManager：
ICourseInfo 接口：
public interface ICourseInfo {
String getCourseName();
byte[] getCourseVideo();
}
ICourseManager 接口：
public interface ICourseManager {
void studyCourse();
void refundCourse();
}
